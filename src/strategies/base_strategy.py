"""
Base Strategy Class with common functionality.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, List, Dict, Any
from datetime import datetime

from ..strategy_formula_engine import (
    SUPPORTED_FORMULA_VARIABLES,
    formula_examples,
    formula_variable_docs,
)


class SignalType(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


class Regime(Enum):
    TRENDING = "TRENDING"
    CHOPPY = "CHOPPY"
    MIXED = "MIXED"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    strategy_name: str
    signal_type: SignalType
    price: float
    timestamp: datetime
    confidence: float  # 0-100
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    trailing_stop: bool = False
    trailing_stop_pct: Optional[float] = None
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'strategy': self.strategy_name,
            'signal': self.signal_type.value,
            'price': self.price,
            'timestamp': self.timestamp.isoformat() if isinstance(self.timestamp, datetime) else str(self.timestamp),
            'confidence': self.confidence,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'trailing_stop': self.trailing_stop,
            'trailing_stop_pct': self.trailing_stop_pct,
            'reasoning': self.reasoning,
            'metadata': self.metadata
        }


@dataclass
class Position:
    """Active trading position."""
    strategy_name: str
    entry_price: float
    entry_time: datetime
    side: str  # 'long' or 'short'
    size: float = 1.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    trailing_stop_active: bool = False
    trailing_stop_price: float = 0.0
    highest_price: float = 0.0  # For trailing long
    lowest_price: float = float('inf')  # For trailing short
    pnl: float = 0.0
    status: str = 'open'  # 'open', 'closed', 'stopped'
    fill_ratio: float = 1.0
    initial_size: float = 0.0
    partial_exit_done: bool = False
    # Regime-aware trailing stop state
    break_even_stop_active: bool = False
    trailing_activation_pnl_met: bool = False
    break_even_state: str = "idle"  # idle | armed | moved | locked | handoff
    break_even_arm_bar_index: Optional[int] = None
    break_even_move_bar_index: Optional[int] = None
    break_even_activation_reason: str = ""
    break_even_move_reason: str = ""
    break_even_costs_pct: float = 0.0
    break_even_buffer_pct: float = 0.0
    break_even_last_update: Dict[str, Any] = field(default_factory=dict)
    break_even_anti_spike_bars_remaining: int = 0
    break_even_anti_spike_consecutive_hits: int = 0
    break_even_anti_spike_consecutive_hits_required: int = 2
    break_even_anti_spike_require_close_beyond: bool = True
    initial_stop_loss: float = 0.0
    partial_take_profit_price: float = 0.0
    partial_tp_filled: bool = False
    partial_tp_size: float = 0.0
    partial_realized_r: float = 0.0
    signal_bar_index: Optional[int] = None
    entry_bar_index: Optional[int] = None
    signal_timestamp: Optional[str] = None
    signal_price: Optional[float] = None
    signal_metadata: Dict[str, Any] = field(default_factory=dict)
    
    def update_trailing_stop(self, current_price: float, trailing_pct: float):
        """Update trailing stop based on price movement."""
        if self.side == 'long':
            if current_price > self.highest_price:
                self.highest_price = current_price
                new_stop = current_price * (1 - trailing_pct / 100)
                if new_stop > self.trailing_stop_price:
                    self.trailing_stop_price = new_stop
        else:  # short
            if current_price < self.lowest_price:
                self.lowest_price = current_price
                new_stop = current_price * (1 + trailing_pct / 100)
                if new_stop < self.trailing_stop_price or self.trailing_stop_price == 0:
                    self.trailing_stop_price = new_stop
    
    def check_stop_hit(self, current_price: float) -> bool:
        """Check if stop loss or trailing stop is hit."""
        if self.trailing_stop_active and self.trailing_stop_price > 0:
            if self.side == 'long' and current_price <= self.trailing_stop_price:
                return True
            if self.side == 'short' and current_price >= self.trailing_stop_price:
                return True
        
        if self.stop_loss > 0:
            if self.side == 'long' and current_price <= self.stop_loss:
                return True
            if self.side == 'short' and current_price >= self.stop_loss:
                return True
        return False
    
    def check_take_profit_hit(self, current_price: float) -> bool:
        """Check if take profit is hit."""
        if self.take_profit > 0:
            if self.side == 'long' and current_price >= self.take_profit:
                return True
            if self.side == 'short' and current_price <= self.take_profit:
                return True
        return False
    
    def calculate_pnl(self, current_price: float) -> float:
        """Calculate current PnL."""
        if self.side == 'long':
            self.pnl = (current_price - self.entry_price) / self.entry_price * 100 * self.size
        else:
            self.pnl = (self.entry_price - current_price) / self.entry_price * 100 * self.size
        return self.pnl
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'strategy': self.strategy_name,
            'entry_price': self.entry_price,
            'entry_time': self.entry_time.isoformat() if isinstance(self.entry_time, datetime) else str(self.entry_time),
            'side': self.side,
            'size': self.size,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'trailing_stop_active': self.trailing_stop_active,
            'trailing_stop_price': self.trailing_stop_price,
            'highest_price': self.highest_price,
            'lowest_price': self.lowest_price,
            'pnl': round(self.pnl, 2),
            'status': self.status,
            'fill_ratio': self.fill_ratio,
            'initial_size': self.initial_size if self.initial_size else self.size,
            'partial_exit_done': self.partial_exit_done,
            'partial_take_profit_price': self.partial_take_profit_price,
            'signal_bar_index': self.signal_bar_index,
            'entry_bar_index': self.entry_bar_index,
            'signal_timestamp': self.signal_timestamp,
            'signal_price': self.signal_price,
            'signal_metadata': self.signal_metadata,
            'break_even_stop_active': self.break_even_stop_active,
            'trailing_activation_pnl_met': self.trailing_activation_pnl_met,
            'break_even_state': self.break_even_state,
            'break_even_arm_bar_index': self.break_even_arm_bar_index,
            'break_even_move_bar_index': self.break_even_move_bar_index,
            'break_even_activation_reason': self.break_even_activation_reason,
            'break_even_move_reason': self.break_even_move_reason,
            'break_even_costs_pct': self.break_even_costs_pct,
            'break_even_buffer_pct': self.break_even_buffer_pct,
            'break_even_last_update': self.break_even_last_update,
            'break_even_anti_spike_bars_remaining': self.break_even_anti_spike_bars_remaining,
            'break_even_anti_spike_consecutive_hits': self.break_even_anti_spike_consecutive_hits,
            'break_even_anti_spike_consecutive_hits_required': (
                self.break_even_anti_spike_consecutive_hits_required
            ),
            'break_even_anti_spike_require_close_beyond': (
                self.break_even_anti_spike_require_close_beyond
            ),
            'initial_stop_loss': self.initial_stop_loss,
            'partial_tp_filled': self.partial_tp_filled,
            'partial_tp_size': self.partial_tp_size,
            'partial_realized_r': self.partial_realized_r,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    """
    
    def __init__(self, name: str, regimes: List[Regime]):
        self.name = name
        self.allowed_regimes = regimes
        self.positions: List[Position] = []
        self.signals_history: List[Signal] = []
        self.enabled = True
        # Per-strategy source selectors:
        # - "custom": use strategy-local params
        # - "global": use module/global params (if set)
        self.exit_mode = "custom"
        self.risk_mode = "custom"
        # Backward-compatible alias for trailing source.
        self.trailing_stop_mode = "custom"
        self.global_trailing_stop_pct: Optional[float] = None
        self.global_rr_ratio: Optional[float] = None
        self.global_atr_stop_multiplier: Optional[float] = None
        self.global_volume_stop_pct: Optional[float] = None
        self.global_min_stop_loss_pct: Optional[float] = None
        # Optional custom formulas evaluated by runtime guardrails.
        self.custom_entry_formula_enabled = False
        self.custom_entry_formula = ""
        self.custom_exit_formula_enabled = False
        self.custom_exit_formula = ""
        self.custom_formula_supported_variables = list(SUPPORTED_FORMULA_VARIABLES)
        self.custom_formula_variable_docs = formula_variable_docs()
        self.custom_formula_examples = formula_examples()
        # Runtime liquidity-sweep-confirmed signals can be enabled/disabled per strategy.
        self.liquidity_sweep_signal_enabled = True
        self.liquidity_sweep_signal_priority = 0
        # Strategies that already use L2 internally should set this True
        self._uses_l2_internally = False
        
    @abstractmethod
    def generate_signal(
        self,
        current_price: float,
        ohlcv: Dict[str, List[float]],
        indicators: Dict[str, Any],
        regime: Regime,
        timestamp: datetime
    ) -> Optional[Signal]:
        """
        Generate trading signal based on market data.
        
        Args:
            current_price: Current market price
            ohlcv: Dict with 'open', 'high', 'low', 'close', 'volume' arrays
            indicators: Dict with indicator values (sma, ema, rsi, atr, vwap)
            regime: Current market regime
            timestamp: Current timestamp
            
        Returns:
            Signal object or None
        """
        pass
    
    def is_allowed_in_regime(self, regime: Regime) -> bool:
        """Check if strategy is allowed in current regime."""
        return regime in self.allowed_regimes

    def apply_l2_flow_boost(
        self,
        signal: Optional['Signal'],
        indicators: Dict[str, Any],
    ) -> Optional['Signal']:
        """
        Adjust signal confidence based on L2 order flow alignment.

        When L2 data is available and the strategy doesn't already use L2
        internally, this checks whether the order flow direction agrees with
        the signal direction.

        - Flow aligned with signal:   confidence += 5 .. 12
        - Flow opposed to signal:     confidence -= 8 .. 15

        The adjustment magnitude scales with the strength of the flow signal.
        Returns the (potentially modified) signal, or None if signal was None.
        """
        if signal is None:
            return None
        if self._uses_l2_internally:
            return signal

        flow = indicators.get("order_flow") or {}
        if not flow.get("has_l2_coverage", False):
            return signal

        # Extract key flow metrics
        signed_aggr = float(flow.get("signed_aggression", 0.0) or 0.0)
        imbalance = float(flow.get("imbalance_avg", 0.0) or 0.0)
        consistency = float(flow.get("directional_consistency", 0.0) or 0.0)

        # Determine signal direction: +1 for BUY, -1 for SELL
        if signal.signal_type == SignalType.BUY:
            direction = 1.0
        elif signal.signal_type == SignalType.SELL:
            direction = -1.0
        else:
            return signal  # HOLD / CLOSE signals — no boost

        # Flow alignment score: how much flow agrees with signal direction
        # Range roughly -1.0 .. +1.0
        aggr_alignment = signed_aggr * direction  # positive = aligned
        imb_alignment = imbalance * direction
        # Consistency is unsigned (0..1), high is good for any direction
        flow_alignment = (
            0.45 * max(-1.0, min(1.0, aggr_alignment / 0.15))
            + 0.35 * max(-1.0, min(1.0, imb_alignment / 0.10))
            + 0.20 * max(-1.0, min(1.0, (consistency - 0.35) / 0.30))
        )

        if flow_alignment > 0.1:
            # Flow confirms signal → boost +5 .. +12
            boost = 5.0 + 7.0 * min(1.0, flow_alignment)
            signal.confidence = min(100.0, signal.confidence + boost)
            signal.metadata["l2_boost"] = round(boost, 1)
        elif flow_alignment < -0.1:
            # Flow opposes signal → penalize -8 .. -15
            penalty = 8.0 + 7.0 * min(1.0, abs(flow_alignment))
            signal.confidence = max(0.0, signal.confidence - penalty)
            signal.metadata["l2_boost"] = round(-penalty, 1)
        # else: neutral zone — no adjustment

        return signal
    
    def calculate_atr_stop(self, price: float, atr: float, multiplier: float = 2.0, side: str = 'long') -> float:
        """Calculate ATR-based stop loss."""
        if side == 'long':
            return price - (atr * multiplier)
        return price + (atr * multiplier)
    
    def calculate_percent_stop(self, price: float, percent: float, side: str = 'long') -> float:
        """Calculate percentage-based stop loss."""
        if side == 'long':
            return price * (1 - percent / 100)
        return price * (1 + percent / 100)
    
    def calculate_take_profit(self, entry: float, stop_loss: float, rr_ratio: float = 2.0, side: str = 'long') -> float:
        """Calculate take profit based on risk-reward ratio."""
        risk = abs(entry - stop_loss)
        if side == 'long':
            return entry + (risk * rr_ratio)
        return entry - (risk * rr_ratio)

    def normalize_source_mode(self, value: Any) -> str:
        """Normalize source mode to one of the supported values."""
        normalized = str(value or "").strip().lower()
        return "global" if normalized == "global" else "custom"

    def normalize_trailing_stop_mode(self, value: Any) -> str:
        """Backward-compatible trailing mode normalization."""
        return self.normalize_source_mode(value)

    def _coerce_positive_float(self, value: Any) -> Optional[float]:
        try:
            parsed = float(value)
        except (TypeError, ValueError):
            return None
        if parsed <= 0:
            return None
        return parsed

    def get_exit_mode(self) -> str:
        raw_exit_mode = getattr(self, "exit_mode", None)
        if raw_exit_mode is not None and str(raw_exit_mode).strip():
            return self.normalize_source_mode(raw_exit_mode)
        return self.normalize_source_mode(getattr(self, "trailing_stop_mode", "custom"))

    def get_risk_mode(self) -> str:
        return self.normalize_source_mode(getattr(self, "risk_mode", "custom"))

    def _resolve_effective_param(
        self,
        *,
        mode: str,
        local_value: Any,
        global_value: Any,
    ) -> Optional[float]:
        local_parsed = self._coerce_positive_float(local_value)
        global_parsed = self._coerce_positive_float(global_value)
        if self.normalize_source_mode(mode) == "global":
            return global_parsed if global_parsed is not None else local_parsed
        return local_parsed if local_parsed is not None else global_parsed

    def get_effective_trailing_stop_pct(self) -> Optional[float]:
        """Resolve trailing stop percent from exit mode and configured values."""
        return self._resolve_effective_param(
            mode=self.get_exit_mode(),
            local_value=getattr(self, "trailing_stop_pct", None),
            global_value=getattr(self, "global_trailing_stop_pct", None),
        )

    def get_effective_rr_ratio(self) -> Optional[float]:
        """Resolve effective risk-reward ratio from exit mode."""
        if not hasattr(self, "rr_ratio"):
            return None
        return self._resolve_effective_param(
            mode=self.get_exit_mode(),
            local_value=getattr(self, "rr_ratio", None),
            global_value=getattr(self, "global_rr_ratio", None),
        )

    def get_effective_atr_stop_multiplier(self) -> Optional[float]:
        """Resolve effective ATR stop multiplier from risk mode."""
        if not hasattr(self, "atr_stop_multiplier"):
            return None
        return self._resolve_effective_param(
            mode=self.get_risk_mode(),
            local_value=getattr(self, "atr_stop_multiplier", None),
            global_value=getattr(self, "global_atr_stop_multiplier", None),
        )

    def get_effective_volume_stop_pct(self) -> Optional[float]:
        """Resolve effective volume-adjusted stop percent from risk mode."""
        if not hasattr(self, "volume_stop_pct"):
            return None
        return self._resolve_effective_param(
            mode=self.get_risk_mode(),
            local_value=getattr(self, "volume_stop_pct", None),
            global_value=getattr(self, "global_volume_stop_pct", None),
        )

    def get_effective_min_stop_loss_pct(self) -> Optional[float]:
        """Resolve effective minimum stop-loss percent from risk mode."""
        if not hasattr(self, "min_stop_loss_pct"):
            return None
        return self._resolve_effective_param(
            mode=self.get_risk_mode(),
            local_value=getattr(self, "min_stop_loss_pct", None),
            global_value=getattr(self, "global_min_stop_loss_pct", None),
        )
    
    def get_vwap_distance(self, price: float, vwap: float) -> float:
        """Calculate distance from VWAP as percentage."""
        return (price - vwap) / vwap * 100
    
    def check_volume_confirmation(self, current_volume: float, avg_volume: float, threshold: float = 1.5) -> bool:
        """Check if volume confirms the move."""
        return current_volume >= avg_volume * threshold

    def get_volume_stats(self, volumes: List[float], lookback: int = 20) -> Dict[str, float]:
        """Return current, average, and ratio for volume."""
        if not volumes:
            return {"current": 0.0, "avg": 0.0, "ratio": 0.0}
        window = min(lookback, len(volumes))
        avg_volume = sum(volumes[-window:]) / window if window else 0.0
        current_volume = volumes[-1] if volumes else 0.0
        ratio = (current_volume / avg_volume) if avg_volume else 0.0
        return {"current": current_volume, "avg": avg_volume, "ratio": ratio}

    def volume_adjusted_pct(
        self,
        base_pct: float,
        volume_ratio: float,
        min_ratio: float = 0.5,
        max_ratio: float = 3.0
    ) -> float:
        """Scale percent by volume ratio (higher volume -> tighter stops)."""
        ratio = volume_ratio if volume_ratio > 0 else 1.0
        ratio = max(min(ratio, max_ratio), min_ratio)
        return base_pct / ratio
    
    def add_signal(self, signal: Signal):
        """Add signal to history."""
        self.signals_history.append(signal)
    
    def get_last_signal(self) -> Optional[Signal]:
        """Get the most recent signal."""
        return self.signals_history[-1] if self.signals_history else None
    
    def open_position(self, signal: Signal) -> Position:
        """Open a new position based on signal."""
        side = 'long' if signal.signal_type == SignalType.BUY else 'short'
        position = Position(
            strategy_name=self.name,
            entry_price=signal.price,
            entry_time=signal.timestamp,
            side=side,
            stop_loss=signal.stop_loss or 0,
            take_profit=signal.take_profit or 0,
            trailing_stop_active=signal.trailing_stop,
            highest_price=signal.price if side == 'long' else 0,
            lowest_price=signal.price if side == 'short' else float('inf')
        )
        self.positions.append(position)
        return position
    
    def get_open_positions(self) -> List[Position]:
        """Get all open positions."""
        return [p for p in self.positions if p.status == 'open']
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize strategy state."""
        payload = {
            'name': self.name,
            'allowed_regimes': [r.value for r in self.allowed_regimes],
            'enabled': self.enabled,
            'liquidity_sweep_signal_enabled': bool(
                getattr(self, "liquidity_sweep_signal_enabled", True)
            ),
            'liquidity_sweep_signal_priority': int(
                getattr(self, "liquidity_sweep_signal_priority", 0) or 0
            ),
            'open_positions': len(self.get_open_positions()),
            'total_signals': len(self.signals_history),
            'last_signal': self.get_last_signal().to_dict() if self.get_last_signal() else None
        }
        has_exit_params = hasattr(self, "trailing_stop_pct") or hasattr(self, "rr_ratio")
        if has_exit_params:
            exit_mode = self.get_exit_mode()
            payload["exit_mode"] = exit_mode
            payload["trailing_stop_mode"] = exit_mode
            payload["global_trailing_stop_pct"] = getattr(self, "global_trailing_stop_pct", None)
            payload["effective_trailing_stop_pct"] = self.get_effective_trailing_stop_pct()
            if hasattr(self, "rr_ratio"):
                payload["global_rr_ratio"] = getattr(self, "global_rr_ratio", None)
                payload["effective_rr_ratio"] = self.get_effective_rr_ratio()
        has_risk_params = (
            hasattr(self, "atr_stop_multiplier")
            or hasattr(self, "volume_stop_pct")
            or hasattr(self, "min_stop_loss_pct")
        )
        if has_risk_params:
            payload["risk_mode"] = self.get_risk_mode()
            if hasattr(self, "atr_stop_multiplier"):
                payload["global_atr_stop_multiplier"] = getattr(
                    self,
                    "global_atr_stop_multiplier",
                    None,
                )
                payload["effective_atr_stop_multiplier"] = self.get_effective_atr_stop_multiplier()
            if hasattr(self, "volume_stop_pct"):
                payload["global_volume_stop_pct"] = getattr(self, "global_volume_stop_pct", None)
                payload["effective_volume_stop_pct"] = self.get_effective_volume_stop_pct()
            if hasattr(self, "min_stop_loss_pct"):
                payload["global_min_stop_loss_pct"] = getattr(
                    self,
                    "global_min_stop_loss_pct",
                    None,
                )
                payload["effective_min_stop_loss_pct"] = self.get_effective_min_stop_loss_pct()
        payload["custom_entry_formula_enabled"] = bool(
            getattr(self, "custom_entry_formula_enabled", False)
        )
        payload["custom_entry_formula"] = str(
            getattr(self, "custom_entry_formula", "") or ""
        )
        payload["custom_exit_formula_enabled"] = bool(
            getattr(self, "custom_exit_formula_enabled", False)
        )
        payload["custom_exit_formula"] = str(
            getattr(self, "custom_exit_formula", "") or ""
        )
        payload["custom_formula_supported_variables"] = list(
            getattr(self, "custom_formula_supported_variables", [])
        )
        payload["custom_formula_variable_docs"] = dict(
            getattr(self, "custom_formula_variable_docs", {})
        )
        payload["custom_formula_examples"] = dict(
            getattr(self, "custom_formula_examples", {})
        )
        return payload
